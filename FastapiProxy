*Thinking...*

> The user has a local FastAPI server and wants to create a new Python project that functions as an MCP (Multi-Cloud Proxy) server with the same routes as their existing FastAPI server. They want to avoid manually recreating all the routes and are asking if they can somehow instantiate a FastAPI app using the OpenAPI JSON specification from their existing server.
> 
> Let me break down what I understand and what solutions might work:
> 
> 1. They have an existing FastAPI server running locally
> 2. They want to create a new, separate Python project that will:
>    - Have all the same routes as their original FastAPI server
>    - Function as an MCP server (using fastapimcp)
> 3. They want to avoid manually recreating all the routes in the new project
> 4. They're asking if they can use the OpenAPI JSON from their existing server to automatically create the new server with the same routes
> 
> For context, FastAPI automatically generates an OpenAPI (formerly Swagger) specification at `/openapi.json` which describes all routes, parameters, request bodies, responses, etc.
> 
> Here are some approaches that might work:
> 
> ### Option 1: Use FastAPI's mount feature
> 
> FastAPI allows you to mount one FastAPI application inside another one, at a specific path prefix. This means you could:
> 
> 1. Import your original FastAPI app into your new project
> 2. Create a new FastAPI app for the MCP server
> 3. Mount the original app into the new one
> 
> ```python
> from fastapi import FastAPI
> from original_project.main import app as original_app
> 
> mcp_app = FastAPI()
> mcp_app.mount("/", original_app)
> 
> # Add MCP-specific configuration to mcp_app
> ```
> 
> ### Option 2: Generate a client from OpenAPI and create proxies
> 
> You could:
> 1. Get the OpenAPI specification from your original FastAPI app (typically at `/openapi.json`)
> 2. Use a tool like `openapi-python-client` to generate a client library
> 3. Create proxy endpoints in your new FastAPI app that call the original app's endpoints through the generated client
> 
> ### Option 3: Parse OpenAPI and dynamically create routes
> 
> You could:
> 1. Fetch the OpenAPI spec from your existing API
> 2. Parse it
> 3. Dynamically create FastAPI routes that forward requests to the original API
> 
> This is more complex but allows for more customization.
> 
> ### Option 4: Use a reverse proxy
> 
> Instead of recreating the API, you could use a reverse proxy library to forward requests from your MCP server to your original FastAPI server.
> 
> Let me provide a more detailed implementation for Option 3, which seems closest to what the user is asking for. This approach would involve parsing the OpenAPI specification and automatically creating routes in the new FastAPI application that mirror the original API:
> 
> ```python
> import json
> import httpx
> from fastapi import FastAPI, Request, Response
> from fastapi.routing import APIRoute
> import inspect
> 
> # Create a new FastAPI app for the MCP server
> mcp_app = FastAPI()
> 
> # Fetch the OpenAPI specification from the original FastAPI server
> async def get_openapi_spec(url="http://localhost:8000/openapi.json"):
>     async with httpx.AsyncClient() as client:
>         response = await client.get(url)
>         return response.json()
> 
> # Original API base URL
> ORIGINAL_API_URL = "http://localhost:8000"
> 
> # Function to dynamically create routes based on OpenAPI spec
> async def create_routes_from_openapi():
>     openapi_spec = await get_openapi_spec()
>     
>     # Extract paths and their operations from the OpenAPI spec
>     paths = openapi_spec.get("paths", {})
>     
>     for path, path_item in paths.items():
>         for method, operation in path_item.items():
>             if method in ["get", "post", "put", "delete", "patch", "options", "head"]:
>                 # Create a route handler that forwards the request to the original API
>                 async def create_route_handler(path=path, method=method):
>                     async def route_handler(request: Request):
>                         # Get the request body if it exists
>                         body = await request.body() if method.lower() in ["post", "put", "patch"] else None
>                         
>                         # Forward the request to the original API
>                         url = f"{ORIGINAL_API_URL}{path}"
>                         
>                         # Forward query parameters
>                         params = dict(request.query_params)
>                         
>                         # Forward headers (optionally)
>                         headers = dict(request.headers)
>                         
>                         async with httpx.AsyncClient() as client:
>                             response = await client.request(
>                                 method=method.upper(),
>                                 url=url,
>                                 params=params,
>                                 headers=headers,
>                                 content=body
>                             )
>                             
>                             # Return the response from the original API
>                             return Response(
>                                 content=response.content,
>                                 status_code=response.status_code,
>                                 headers=dict(response.headers)
>                             )
>                     
>                     return route_handler
>                 
>                 # Get operation ID or create one
>                 operation_id = operation.get("operationId", f"{method}_{path}")
>                 
>                 # Generate a summary for the route
>                 summary = operation.get("summary", f"{method.upper()} {path}")
>                 
>                 # Add the route to the MCP app
>                 route_handler = await create_route_handler()
>                 route_handler.__name__ = operation_id
>                 
>                 # Get the request body schema if it exists
>                 request_body = operation.get("requestBody", {})
>                 
>                 # Get the responses schema
>                 responses = operation.get("responses", {})
>                 
>                 # Add the route to the FastAPI app
>                 mcp_app.add_api_route(
>                     path=path,
>                     endpoint=route_handler,
>                     methods=[method.upper()],
>                     summary=summary,
>                     description=operation.get("description", ""),
>                     response_model=None,  # This would need to be dynamically created based on the response schema
>                     tags=operation.get("tags", []),
>                 )
> 
> # Call this function during startup
> @mcp_app.on_event("startup")
> async def startup_event():
>     await create_routes_from_openapi()
> ```
> 
> However, this approach has some limitations:
> 1. It creates proxy routes, not actual routes with the same functionality
> 2. It doesn't handle more complex FastAPI features like dependencies, custom response models, etc.
> 3. Request/response validation would be handled by the original API, not the MCP server
> 
> Let me think a bit more about what the user is asking. They specifically mention using the "fastapimcp" project to turn their API into an MCP server. I'm not familiar with a specific project called "fastapimcp" - this might be an internal or custom library they're using. However, if we're talking about creating a Multi-Cloud Proxy server, then what they probably want is to have their API available across multiple cloud environments or regions.
> 
> If that's the case, the best approach might be to have the MCP server act as a proxy to the original FastAPI server, while maintaining the same API contract.
> 
> Let me also note that generating a FastAPI app directly from an OpenAPI specification is not a built-in feature of FastAPI. However, there are tools like `openapi-python-client` that can generate client libraries from OpenAPI specs, which could then be used to implement the proxy functionality.
> 
> Let me look at another approach that might better fit what the user is asking for.
> 
> ### More direct approach: Using http-router and httpx
> 
> We could create a simple FastAPI app that uses httpx to proxy requests to the original FastAPI server, while using the OpenAPI spec to register the routes:
> 
> ```python
> import json
> import httpx
> from fastapi import FastAPI, Request, Response, HTTPException
> from pydantic import create_model, BaseModel
> import typing
> 
> # Create a new FastAPI app
> app = FastAPI()
> 
> # Original API base URL
> ORIGINAL_API_URL = "http://localhost:8000"
> 
> # Fetch OpenAPI spec from the original API
> async def get_openapi_spec():
>     async with httpx.AsyncClient() as client:
>         try:
>             response = await client.get(f"{ORIGINAL_API_URL}/openapi.json")
>             response.raise_for_status()
>             return response.json()
>         except httpx.HTTPError as e:
>             raise HTTPException(status_code=500, detail=f"Failed to fetch OpenAPI spec: {str(e)}")
> 
> # Create a proxy handler for any route
> async def proxy_handler(request: Request):
>     # Extract path and query parameters
>     path = request.url.path
>     query_params = str(request.url.query)
>     query_string = f"?{query_params}" if query_params else ""
>     
>     # Build target URL
>     target_url = f"{ORIGINAL_API_URL}{path}{query_string}"
>     
>     # Get request method and body
>     method = request.method
>     body = await request.body()
>     headers = dict(request.headers)
>     
>     # Forward the request to the original API
>     async with httpx.AsyncClient() as client:
>         try:
>             response = await client.request(
>                 method=method,
>                 url=target_url,
>                 headers=headers,
>                 content=body
>             )
>             
>             # Return the response from the original API
>             return Response(
>                 content=response.content,
>                 status_code=response.status_code,
>                 headers=dict(response.headers)
>             )
>         except httpx.HTTPError as e:
>             raise HTTPException(status_code=500, detail=f"Proxy request failed: {str(e)}")
> 
> # Dynamic route creation based on OpenAPI spec
> @app.on_event("startup")
> async def register_routes():
>     spec = await get_openapi_spec()
>     
>     # Extract paths from the spec
>     paths = spec.get("paths", {})
>     
>     for path, path_item in paths.items():
>         for method, operation in path_item.items():
>             if method.lower() in ["get", "post", "put", "delete", "patch", "options", "head"]:
>                 # Register the route with the proxy handler
>                 app.add_api_route(
>                     path=path,
>                     endpoint=proxy_handler,
>                     methods=[method.upper()],
>                     summary=operation.get("summary", ""),
>                     description=operation.get("description", ""),
>                     tags=operation.get("tags", [])
>                 )
> ```
> 
> This approach creates a FastAPI app that:
> 1. Fetches the OpenAPI specification from the original FastAPI server
> 2. For each route defined in the spec, registers a corresponding route in the new app
> 3. Each route uses a proxy handler that forwards requests to the original server
> 
> This keeps the API contract the same (including route paths, HTTP methods, etc.) while allowing the new app to be modified for MCP functionality.
> 
> Let me refine this approach a bit more to address potential issues and make it more robust:
> 
> ```python
> import json
> import httpx
> from fastapi import FastAPI, Request, Response, HTTPException, Depends
> from pydantic import create_model, BaseModel
> import typing
> from urllib.parse import urljoin
> 
> # Create a new FastAPI app
> app = FastAPI(title="MCP Server")
> 
> # Original API base URL
> ORIGINAL_API_URL = "http://localhost:8000"
> 
> # Fetch OpenAPI spec from the original API
> async def get_openapi_spec():
>     async with httpx.AsyncClient() as client:
>         try:
>             response = await client.get(f"{ORIGINAL_API_URL}/openapi.json")
>             response.raise_for_status()
>             return response.json()
>         except httpx.HTTPError as e:
>             raise HTTPException(status_code=500, detail=f"Failed to fetch OpenAPI spec: {str(e)}")
> 
> # Create a proxy handler for a specific route
> def create_proxy_handler(path: str, method: str):
>     async def proxy_handler(request: Request):
>         # Get the request body if it exists
>         body = await request.body() if method.lower() in ["post", "put", "patch"] else None
>         
>         # Extract query parameters
>         query_params = str(request.url.query)
>         query_string = f"?{query_params}" if query_params else ""
>         
>         # Build target URL
>         target_url = f"{ORIGINAL_API_URL}{path}{query_string}"
>         
>         # Forward headers (excluding host)
>         headers = dict(request.headers)
>         if "host" in headers:
>             del headers["host"]
>         
>         # Forward the request to the original API
>         async with httpx.AsyncClient() as client:
>             try:
>                 response = await client.request(
>                     method=method.upper(),
>                     url=target_url,
>                     headers=headers,
>                     content=body
>                 )
>                 
>                 # Return the response from the original API
>                 return Response(
>                     content=response.content,
>                     status_code=response.status_code,
>                     headers=dict(response.headers)
>                 )
>             except httpx.HTTPError as e:
>                 raise HTTPException(status_code=500, detail=f"Proxy request failed: {str(e)}")
>     
>     return proxy_handler
> 
> # Dynamic route creation based on OpenAPI spec
> @app.on_event("startup")
> async def register_routes():
>     spec = await get_openapi_spec()
>     
>     # Extract paths from the spec
>     paths = spec.get("paths", {})
>     
>     for path, path_item in paths.items():
>         for method, operation in path_item.items():
>             if method.lower() in ["get", "post", "put", "delete", "patch", "options", "head"]:
>                 # Create a unique handler for this path and method
>                 handler = create_proxy_handler(path, method)
>                 
>                 # Use operation ID as function name or generate one
>                 operation_id = operation.get("operationId", f"{method}_{path.replace('/', '_')}")
>                 handler.__name__ = operation_id
>                 
>                 # Register the route with the proxy handler
>                 app.add_api_route(
>                     path=path,
>                     endpoint=handler,
>                     methods=[method.upper()],
>                     summary=operation.get("summary", ""),
>                     description=operation.get("description", ""),
>                     tags=operation.get("tags", [])
>                 )
>     
>     # Also add a catch-all route for paths not in the spec (optional)
>     @app.api_route("/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"])
>     async def catch_all(request: Request, path: str):
>         # Build target URL
>         full_path = request.url.path
>         query_params = str(request.url.query)
>         query_string = f"?{query_params}" if query_params else ""
>         target_url = f"{ORIGINAL_API_URL}{full_path}{query_string}"
>         
>         # Get request method and body
>         method = request.method
>         body = await request.body()
>         headers = dict(request.headers)
>         if "host" in headers:
>             del headers["host"]
>         
>         # Forward the request to the original API
>         async with httpx.AsyncClient() as client:
>             try:
>                 response = await client.request(
>                     method=method,
>                     url=target_url,
>                     headers=headers,
>                     content=body
>                 )
>                 
>                 return Response(
>                     content=response.content,
>                     status_code=response.status_code,
>                     headers=dict(response.headers)
>                 )
>             except httpx.HTTPError as e:
>                 raise HTTPException(status_code=500, detail=f"Proxy request failed: {str(e)}")
> ```
> 
> This refined version:
> 1. Creates unique handlers for each path and method to better handle routing
> 2. Uses operation IDs from the OpenAPI spec for function names
> 3. Adds a catch-all route for any paths not explicitly defined in the spec
> 4. Handles headers more carefully, removing the "host" header to avoid conflicts
> 
> Once this proxy server is set up, you can then apply your "fastapimcp" functionality to turn it into an MCP server.
> 
> Now, let me address the specific part of the question: "Can we avoid creating all the routes but directly instantiate a fastapi using its constructor and a openapi json from a url"
> 
> FastAPI doesn't directly support creating an app from an OpenAPI spec, but as we've shown, we can parse the spec and dynamically create routes. There's no built-in constructor that takes an OpenAPI spec URL and automatically sets up all routes.
> 
> However, there are some libraries that might help with this approach:
> 
> 1. **connexion**: A library that directly uses OpenAPI/Swagger specifications to validate and route requests to Python functions
> 2. **openapi-core**: A library for OpenAPI spec validation that could be used with FastAPI
> 
> Let me provide one more alternative using connexion, which might be simpler if what you want is to create an API from an OpenAPI spec:
> 
> ```python
> import connexion
> from fastapi import FastAPI
> import httpx
> 
> # Create a Connexion app
> connexion_app = connexion.AsyncApp(__name__)
> 
> # Original API URL
> ORIGINAL_API_URL = "http://localhost:8000"
> 
> # Function to handle all requests
> async def proxy_request(request):
>     # Extract the current path
>     path = request.path
>     method = request.method.lower()
>     
>     # Forward the request to the original API
>     url = f"{ORIGINAL_API_URL}{path}"
>     headers = dict(request.headers)
>     if "host" in headers:
>         del headers["host"]
>     
>     body = await request.body if hasattr(request, "body") else None
>     
>     # Send the request to the original API
>     async with httpx.AsyncClient() as client:
>         response = await client.request(
>             method=method,
>             url=url,
>             headers=headers,
>             content=body,
>             params=request.args
>         )
>         
>         # Return the response
>         return response.json(), response.status_code
> 
> # Add the spec to the connexion app, with a request handler for each operation
> connexion_app.add_api_from_url(
>     f"{ORIGINAL_API_URL}/openapi.json",
>     resolver=connexion.resolver.MethodViewResolver(),
>     validate_responses=False,
>     arguments={"proxy_request": proxy_request}
> )
> 
> # Create a FastAPI app
> app = FastAPI()
> 
> # Mount the connexion app to the FastAPI app
> app.mount("/", connexion_app)
> 
> # Add MCP-specific functionality to the FastAPI app
> # ...
> ```
> 
> This approach uses connexion to handle the OpenAPI spec and route creation, then mounts it into a FastAPI app. However, connexion uses Flask under the hood, not FastAPI, so there might be some compatibility issues.
> 
> Based on all these approaches, I believe the best solution for the user is the dynamic route creation approach using FastAPI's built-in capabilities:
> 
> ```python
> import httpx
> from fastapi import FastAPI, Request, Response, HTTPException
> 
> # Create new FastAPI app
> app = FastAPI(title="MCP Server")
> 
> # Original API URL
> ORIGINAL_API_URL = "http://localhost:8000"
> 
> # Function to create a route handler for a specific path and method
> def create_route_handler(path: str, method: str):
>     async def route_handler(request: Request):
>         body = await request.body() if method.lower() in ["post", "put", "patch"] else None
>         
>         # Build target URL with query parameters
>         query_params = str(request.url.query)
>         query_string = f"?{query_params}" if query_params else ""
>         target_url = f"{ORIGINAL_API_URL}{path}{query_string}"
>         
>         # Forward headers
>         headers = dict(request.headers)
>         if "host" in headers:
>             del headers["host"]
>         
>         # Forward the request
>         async with httpx.AsyncClient() as client:
>             try:
>                 response = await client.request(
>                     method=method.upper(),
>                     url=target_url,
>                     headers=headers,
>                     content=body
>                 )
>                 
>                 # Return the response
>                 return Response(
>                     content=response.content,
>                     status_code=response.status_code,
>                     headers=dict(response.headers)
>                 )
>             except httpx.HTTPError as e:
>                 raise HTTPException(status_code=500, detail=f"Proxy request failed: {str(e)}")
>     
>     return route_handler
> 
> # Fetch and parse OpenAPI spec on startup
> @app.on_event("startup")
> async def setup_routes():
>     # Fetch OpenAPI spec
>     async with httpx.AsyncClient() as client:
>         response = await client.get(f"{ORIGINAL_API_URL}/openapi.json")
>         spec = response.json()
>     
>     # Create routes based on the spec
>     for path, path_item in spec.get("paths", {}).items():
>         for method, operation in path_item.items():
>             if method.lower() in ["get", "post", "put", "delete", "patch", "options", "head"]:
>                 # Create a handler for this route
>                 handler = create_route_handler(path, method)
>                 
>                 # Set handler name (for better debugging)
>                 operation_id = operation.get("operationId", f"{method}_{path.replace('/', '_')}")
>                 handler.__name__ = operation_id
>                 
>                 # Add the route to our app
>                 app.add_api_route(
>                     path=path,
>                     endpoint=handler,
>                     methods=[method.upper()],
>                     summary=operation.get("summary", ""),
>                     description=operation.get("description", ""),
>                     tags=operation.get("tags", [])
>                 )
> ```
> 
> This approach:
> 1. Creates a new FastAPI app
> 2. Fetches the OpenAPI spec from the original API at startup
> 3. Dynamically creates route handlers for each path and method in the spec
> 4. These handlers forward requests to the original API
> 5. The app maintains the same API contract as the original
> 
> Once this is set up, the user can apply their "fastapimcp" functionality to this app to turn it into an MCP server.
> 
> I believe this is the most straightforward approach to achieve what the user is asking for.


You can create a proxy FastAPI application that mirrors your existing FastAPI server's routes by using the OpenAPI schema. Here's how to do it:

```python
import httpx
from fastapi import FastAPI, Request, Response, HTTPException

# Create a new FastAPI app for the MCP server
app = FastAPI(title="MCP Server")

# Original FastAPI server URL
ORIGINAL_API_URL = "http://localhost:8000"  # Adjust as needed

# Create a route handler that proxies requests to the original server
def create_route_handler(path: str, method: str):
    async def route_handler(request: Request):
        # Get request body if needed
        body = await request.body() if method.lower() in ["post", "put", "patch"] else None
        
        # Build target URL with query parameters
        query_params = str(request.url.query)
        query_string = f"?{query_params}" if query_params else ""
        target_url = f"{ORIGINAL_API_URL}{path}{query_string}"
        
        # Forward headers (excluding host)
        headers = dict(request.headers)
        if "host" in headers:
            del headers["host"]
        
        # Forward the request to the original server
        async with httpx.AsyncClient() as client:
            try:
                response = await client.request(
                    method=method.upper(),
                    url=target_url,
                    headers=headers,
                    content=body
                )
                
                # Return the response from the original server
                return Response(
                    content=response.content,
                    status_code=response.status_code,
                    headers=dict(response.headers)
                )
            except httpx.HTTPError as e:
                raise HTTPException(status_code=500, detail=f"Proxy request failed: {str(e)}")
    
    return route_handler

# Register routes based on OpenAPI schema at startup
@app.on_event("startup")
async def setup_routes():
    # Fetch OpenAPI schema from original server
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{ORIGINAL_API_URL}/openapi.json")
        openapi_schema = response.json()
    
    # Create routes based on the schema
    for path, path_item in openapi_schema.get("paths", {}).items():
        for method, operation in path_item.items():
            if method.lower() in ["get", "post", "put", "delete", "patch", "options", "head"]:
                # Create a handler for this route
                handler = create_route_handler(path, method)
                
                # Set handler name for better debugging
                operation_id = operation.get("operationId", f"{method}_{path.replace('/', '_')}")
                handler.__name__ = operation_id
                
                # Register the route with our app
                app.add_api_route(
                    path=path,
                    endpoint=handler,
                    methods=[method.upper()],
                    summary=operation.get("summary", ""),
                    description=operation.get("description", ""),
                    tags=operation.get("tags", [])
                )
```

To use this:

1. Install the required dependencies: `pip install fastapi httpx uvicorn`
2. Save this code in a new project (e.g., `mcp_server.py`)
3. Run it with: `uvicorn mcp_server:app --port 8001` (using a different port than your original server)
4. After this is running, you can integrate with fastapimcp to turn it into a full MCP server

This approach avoids having to manually recreate all your routes by:
1. Fetching the OpenAPI schema from your original FastAPI server
2. Dynamically creating proxy routes that match the original API
3. Forwarding all requests to your original server

Each registered route will have the same path, method, and documentation as your original FastAPI server.




import json
import httpx
from fastapi import FastAPI, Request, Response, HTTPException, Body
from fastapi.responses import JSONResponse
from pydantic import create_model, BaseModel, Field
from typing import Dict, List, Any, Optional, Union, get_type_hints, Type
import inspect
from enum import Enum

# Create the FastAPI app
app = FastAPI(title="MCP Server Proxy")

# Original API URL
ORIGINAL_API_URL = "http://localhost:8000"

# Cache for OpenAPI spec
openapi_cache = None

async def get_openapi_spec():
    global openapi_cache
    if openapi_cache is not None:
        return openapi_cache
    
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{ORIGINAL_API_URL}/openapi.json")
        if response.status_code != 200:
            raise HTTPException(status_code=500, detail=f"Failed to fetch OpenAPI spec: {response.status_code}")
        openapi_cache = response.json()
        return openapi_cache

# Convert OpenAPI schemas to Pydantic models
def create_pydantic_model_from_schema(schema, name):
    if not schema:
        return None
    
    properties = schema.get("properties", {})
    required = schema.get("required", [])
    fields = {}
    
    for prop_name, prop_schema in properties.items():
        field_type = Any
        field_kwargs = {}
        
        if "type" in prop_schema:
            if prop_schema["type"] == "string":
                field_type = str
            elif prop_schema["type"] == "integer":
                field_type = int
            elif prop_schema["type"] == "number":
                field_type = float
            elif prop_schema["type"] == "boolean":
                field_type = bool
            elif prop_schema["type"] == "array":
                field_type = List[Any]
            elif prop_schema["type"] == "object":
                field_type = Dict[str, Any]
        
        if "description" in prop_schema:
            field_kwargs["description"] = prop_schema["description"]
        
        if prop_name not in required:
            field_type = Optional[field_type]
            field_kwargs["default"] = None
        
        fields[prop_name] = (field_type, Field(**field_kwargs))
    
    return create_model(name, **fields)

# Create MCP tool definitions from OpenAPI paths
async def create_mcp_tools():
    spec = await get_openapi_spec()
    tools = []
    
    for path, path_item in spec.get("paths", {}).items():
        for method, operation in path_item.items():
            if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                continue
                
            operation_id = operation.get("operationId", f"{method}_{path}")
            
            # Create parameter schema
            parameters = []
            for param in operation.get("parameters", []):
                parameters.append({
                    "name": param["name"],
                    "description": param.get("description", ""),
                    "type": param["schema"].get("type", "string"),
                    "required": param.get("required", False)
                })
            
            # Handle request body
            if "requestBody" in operation:
                content = operation["requestBody"].get("content", {})
                schema = None
                
                # Try to get schema from application/json or first available content type
                if "application/json" in content:
                    schema = content["application/json"].get("schema", {})
                elif content:
                    first_content = next(iter(content.values()))
                    schema = first_content.get("schema", {})
                
                if schema:
                    for prop_name, prop_schema in schema.get("properties", {}).items():
                        param = {
                            "name": prop_name,
                            "description": prop_schema.get("description", ""),
                            "type": prop_schema.get("type", "string"),
                            "required": prop_name in schema.get("required", [])
                        }
                        parameters.append(param)
            
            # Create tool definition
            tool = {
                "name": operation_id,
                "description": operation.get("summary", "") or operation.get("description", ""),
                "parameters": parameters
            }
            tools.append(tool)
    
    return tools

# Proxy handler for API requests
async def proxy_request(path: str, method: str, request: Request):
    # Get request body if needed
    body = await request.body() if method.lower() in ["post", "put", "patch"] else None
    
    # Build target URL with query parameters
    query_params = str(request.url.query)
    query_string = f"?{query_params}" if query_params else ""
    target_url = f"{ORIGINAL_API_URL}{path}{query_string}"
    
    # Forward headers (excluding host)
    headers = dict(request.headers)
    if "host" in headers:
        del headers["host"]
    
    # Forward the request to the original server
    async with httpx.AsyncClient() as client:
        try:
            response = await client.request(
                method=method.upper(),
                url=target_url,
                headers=headers,
                content=body
            )
            
            # Return the response from the original server
            return Response(
                content=response.content,
                status_code=response.status_code,
                headers=dict(response.headers)
            )
        except httpx.HTTPError as e:
            raise HTTPException(status_code=500, detail=f"Proxy request failed: {str(e)}")

# Create routes from OpenAPI spec
@app.on_event("startup")
async def setup_routes():
    spec = await get_openapi_spec()
    
    # Register API routes from the spec
    for path, path_item in spec.get("paths", {}).items():
        for method, operation in path_item.items():
            if method.lower() not in ["get", "post", "put", "delete", "patch", "options", "head"]:
                continue
                
            operation_id = operation.get("operationId", f"{method}_{path.replace('/', '_')}")
            
            # Create the route
            async def route_handler(request: Request, path=path, method=method):
                return await proxy_request(path, method, request)
            
            route_handler.__name__ = operation_id
            
            # Add the route to our app
            app.add_api_route(
                path=path,
                endpoint=route_handler,
                methods=[method.upper()],
                summary=operation.get("summary", ""),
                description=operation.get("description", ""),
                tags=operation.get("tags", [])
            )

# MCP Endpoints
@app.get("/mcp", include_in_schema=False)
async def mcp_base_endpoint():
    return JSONResponse(content={
        "type": "mcp:server",
        "version": "1.0.0",
        "name": "FastAPI MCP Proxy",
        "description": "MCP proxy for a remote FastAPI server",
        "publisher": "api-proxy",
        "endpoints": {
            "sse": "/mcp/sse",
            "stdio": "/mcp/stdio"
        }
    })

# SSE endpoint for MCP
@app.get("/mcp/sse", include_in_schema=False)
async def mcp_sse_endpoint(request: Request):
    # Create SSE response headers
    headers = {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
    }
    
    # Create SSE streaming response
    async def event_generator():
        # Send server info
        tools = await create_mcp_tools()
        server_info = {
            "type": "server_info",
            "name": "FastAPI MCP Proxy",
            "description": "MCP proxy for a remote FastAPI server",
            "tools": tools
        }
        yield f"event: server_info\ndata: {json.dumps(server_info)}\n\n"
        
        # Keep the connection alive
        while True:
            await asyncio.sleep(30)
            yield f"event: ping\ndata: {{}}\n\n"
    
    return StreamingResponse(event_generator(), headers=headers)

# STDIO endpoint for MCP
@app.post("/mcp/stdio", include_in_schema=False)
async def mcp_stdio_endpoint(request: Request):
    body = await request.json()
    
    # Parse request type and handle accordingly
    if body.get("type") == "server_info_request":
        tools = await create_mcp_tools()
        return JSONResponse(content={
            "type": "server_info",
            "name": "FastAPI MCP Proxy",
            "description": "MCP proxy for a remote FastAPI server",
            "tools": tools
        })
    elif body.get("type") == "tool_call":
        tool_call = body.get("tool_call", {})
        tool_name = tool_call.get("name")
        tool_params = tool_call.get("parameters", {})
        
        # Find the matching tool from our OpenAPI spec
        spec = await get_openapi_spec()
        tool_path = None
        tool_method = None
        
        for path, path_item in spec.get("paths", {}).items():
            for method, operation in path_item.items():
                if method.lower() not in ["get", "post", "put", "delete", "patch"]:
                    continue
                
                operation_id = operation.get("operationId", f"{method}_{path.replace('/', '_')}")
                if operation_id == tool_name:
                    tool_path = path
                    tool_method = method
                    break
            
            if tool_path:
                break
        
        if not tool_path:
            return JSONResponse(content={
                "type": "tool_call_error",
                "error": f"Tool '{tool_name}' not found"
            }, status_code=404)
        
        # Build request to the original API
        # Replace path parameters
        final_path = tool_path
        path_params = {}
        query_params = {}
        body_params = {}
        
        # Extract path parameters
        for param in spec.get("paths", {}).get(tool_path, {}).get(tool_method, {}).get("parameters", []):
            if param.get("in") == "path":
                param_name = param.get("name")
                if param_name in tool_params:
                    path_params[param_name] = tool_params[param_name]
                    final_path = final_path.replace(f"{{{param_name}}}", str(tool_params[param_name]))
            elif param.get("in") == "query":
                param_name = param.get("name")
                if param_name in tool_params:
                    query_params[param_name] = tool_params[param_name]
        
        # Handle body parameters
        if tool_method.lower() in ["post", "put", "patch"]:
            body_schema = spec.get("paths", {}).get(tool_path, {}).get(tool_method, {}).get("requestBody", {}).get("content", {}).get("application/json", {}).get("schema", {})
            if body_schema:
                for param_name in tool_params:
                    if param_name not in path_params and param_name not in query_params:
                        body_params[param_name] = tool_params[param_name]
        
        # Build query string
        query_string = "&".join([f"{k}={v}" for k, v in query_params.items()]) if query_params else ""
        target_url = f"{ORIGINAL_API_URL}{final_path}"
        if query_string:
            target_url = f"{target_url}?{query_string}"
        
        # Make the request to the original API
        headers = {"Content-Type": "application/json"}
        
        async with httpx.AsyncClient() as client:
            try:
                response = await client.request(
                    method=tool_method.upper(),
                    url=target_url,
                    headers=headers,
                    json=body_params if body_params else None
                )
                
                # Return the tool call result
                try:
                    response_data = response.json()
                except:
                    response_data = {"raw_content": response.text}
                
                return JSONResponse(content={
                    "type": "tool_call_result",
                    "result": response_data
                })
            except httpx.HTTPError as e:
                return JSONResponse(content={
                    "type": "tool_call_error",
                    "error": f"API request failed: {str(e)}"
                }, status_code=500)
    
    # Default response for unknown request types
    return JSONResponse(content={
        "type": "error",
        "error": "Unknown request type"
    }, status_code=400)

# Import asyncio for the SSE generator
import asyncio
from fastapi.responses import StreamingResponse




async def get_openapi_spec(base_url: str) -> dict:
    """
    Fetch the OpenAPI specification from a remote FastAPI server using httpx.
    
    Args:
        base_url: The base URL of the FastAPI server
    
    Returns:
        The OpenAPI specification as a Python dictionary
    """
    # Make sure the URL doesn't end with a slash
    if base_url.endswith('/'):
        base_url = base_url[:-1]
    
    openapi_url = f"{base_url}/openapi.json"
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(openapi_url)
            response.raise_for_status()  # Raise an exception for 4XX/5XX responses
            return response.json()
    except httpx.HTTPError as e:
        print(f"HTTP error occurred: {e}")
        raise
    except json.JSONDecodeError:
        print("Failed to decode JSON response")
        raise
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        raise
